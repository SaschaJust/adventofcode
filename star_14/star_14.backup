use Bitwise
{:ok, input} = File.read("star_14.sample")

defmodule Star10 do
  def reverse({rev_rhs, rev_lhs}, {const_lhs, const_rhs}) do
      {new_rhs, new_lhs} = rev_rhs ++ rev_lhs |> Enum.reverse |> Enum.split(Enum.count(rev_rhs))
      new_lhs ++ const_lhs ++ new_rhs ++ const_rhs
  end

  def pinch([ length | remainder ], list, position, skip_size) do
    pinch(
      remainder,
      reverse(
        {
          Enum.slice(list, position, length),
          Enum.slice(list, 0, (if position + length > Enum.count(list), do: rem(position+length, Enum.count(list)), else: 0))
        },
        {
          Enum.slice(list, (if position + length > Enum.count(list), do: rem(position+length, Enum.count(list)), else: 0), position-(if position + length > Enum.count(list), do: rem(position+length, Enum.count(list)), else: 0)),
          Enum.slice(list, position+length, Enum.count(list))
        }
      ),
      rem(position+length+skip_size, Enum.count(list)),
      skip_size+1
    )
  end

  def pinch([], list, _, _) do
    list
  end
end

defmodule Star14 do
  def knot_hash(input) do
    Enum.to_list(1..64)
      |> Enum.reduce([], fn(_, acc) -> acc ++ (input |> String.trim |> to_charlist) ++ [17,31,73,47,23] end)
      |> Star10.pinch(Enum.to_list(0..255), 0, 0)
      |> Enum.chunk_every(16)
      |> Enum.map(fn x -> x |> Enum.reduce(0, &^^^/2) end)
      |> Enum.reduce("", fn(x, acc) -> acc <> Base.encode16(<<x>>) end)
  end

  def square_count([]) do
    0
  end

  def square_count([hash | tail]) do
    (hash
      |> String.graphemes
      |> Enum.map(fn(x) -> {value, _} = Integer.parse(x,16);
        for(<<bit::1 <- :binary.encode_unsigned(value)>>, do: bit) |> Enum.sum
      end)
      |> Enum.sum
    ) + square_count tail
  end

  def grid([], _, map) do
    map
  end

  def grid([hash | tail], row, map) do
    grid(
      tail,
      row+1,
      Map.put(map,
        row,
        hash
          |> String.graphemes
          |> Enum.flat_map(fn(x) -> {value, _} = Integer.parse(x,16); value |> i2b end)
      )
    )
  end

  def grid_get(grid, {x, y}) do
    case Map.get(grid, y) do
      nil -> false
      list -> list |> Enum.at(x)
    end
  end

  def visit(grid, list = [{x, y} | remainder], visited) when x>=0 and x<128 and y>=0 and y<128 do
    # IO.inspect list
    result = cond do
      visited |> MapSet.member?({x, y}) -> visit(grid, remainder, visited)
      grid |> grid_get({x, y}) |> Kernel.not -> visit(grid, remainder, visited |> MapSet.put({x, y}))
      true -> [{x-1,y}, {x+1, y}, {x, y-1}, {x, y+1}]
          |> Enum.filter(&(visited |> MapSet.member?(&1) |> Kernel.not))
          |> (&visit(grid, &1, visited |> MapSet.put({x, y}))).()
    end
    result
  end

  def visit(grid, [{x, y} | remainder], visited) do
    visit(grid, remainder, visited)
  end

  def visit(_, [], visited) do
    visited
  end

  def regions(_, index, []) do
    index
  end

  def regions(grid, index, [{x, y} | remainder ], visited) do
    # IO.inspect remainder;
    case grid |> grid_get({x, y}) do
      true -> new_visited = (grid |> visit([{x, y}], visited));
              new_remainder = remainder -- (new_visited |> MapSet.to_list);
              IO.puts "#{index}: #{Enum.count(new_visited)}";
              # IO.inspect new_visited
              regions(grid, index+1, new_remainder, new_visited)
      _ -> regions(grid, index, remainder, visited)
    end
  end

  def i2b(value) do
    [ (value &&& 8) != 0, (value &&& 4) != 0, (value &&& 2) != 0, (value &&& 1) != 0 ]
  end
end

hash_list =
Enum.to_list(0..127)
  |> Enum.map(fn(x) -> (input |> String.trim) <> "-" <> Integer.to_string(x) |> Star14.knot_hash end)

hash_list
  |> Star14.square_count
  |> IO.inspect

grid = hash_list
  |> Star14.grid(0, Map.new)

grid
  |> Map.to_list
  |> Enum.sort(fn({x1, y1}, {x2, y2}) -> x1 <= x2 end)
  |> Enum.reduce("", fn({x, y}, acc2) -> acc2 <> "#{x}: " <> (y |> Enum.reduce("", fn(x, acc) -> acc <> if x, do: "#", else: "." end)) <> "\n" end ) |> IO.puts

grid
  |> Star14.regions(0, for x<-0..127, y<-0..127 do {x, y} end, MapSet.new)
  |> IO.inspect
